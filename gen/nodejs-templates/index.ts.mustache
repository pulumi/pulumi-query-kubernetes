// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
//

import * as k8s from "@pulumi/kubernetes";
import * as pulumi from "@pulumi/pulumi";
import { Resource } from "@pulumi/pulumi";
import { ResolvedResource } from "@pulumi/pulumi/queryable";
import { streamInvoke } from "@pulumi/pulumi/runtime";
import * as query from "@pulumi/query";
import { AsyncIterable } from "@pulumi/query/interfaces";
import * as rx from "rxjs";
import { map, scan } from "rxjs/operators";

//
// Implementation of `list`.
//

/**
 * Lists all Kubernetes resources of a specific type live in a cluster. Resource types are
 * identified with traditional Kubernetes `apiVersion` and `kind`. For example `list("v1", "Pod")`
 * produces a set of Pods.
 *
 * By default, `list` operates on the cluster and namespace identified by the active context of the
 * kubeconfig file. Namespace can be specified manually with the optional `namespace` parameter.
 *
 * The return value of `list` implements `AsyncQueryable`, which exposes powerful facilities for
 * filtering, mapping, and joining resources sets to other resource sets. The following example
 * produces the distinct versions of MySQL running in the active context in the kubeconfig file.
 *
 * ```typescript
 * import * as kq from "@pulumi/query-kubernetes";
 *
 * // Find all distinct versions of MySQL running in your cluster.
 * const mySqlVersions = kq
 *     .list("v1", "Pod")
 *     .flatMap(pod => pod.spec.containers)
 *     .map(container => container.image)
 *     .filter(imageName => imageName.includes("mysql"))
 *     .distinct();
 *
 * mySqlVersions.forEach(console.log);
 * ```
 */
{{#Groups}}
{{#Versions}}
{{#Kinds}}
export function list(apiVersion: "{{RawAPIVersion}}", kind: "{{Kind}}", namespace?: string): query.AsyncQueryable<ResolvedResource<k8s.{{Group}}.{{Version}}.{{Kind}}>>;
{{/Kinds}}
{{/Versions}}
{{/Groups}}
export function list<U extends Resource>(apiVersion: string, kind: string, namespace: string = "default"): query.AsyncQueryable<ResolvedResource<U>> {

    let gvk: { group: string; version: string; kind: string };
    let pulumiType: string;
    let filter: (obj: any) => obj is ResolvedResource<U>;
    switch (`${apiVersion}::${kind}`) {
{{#Groups}}
{{#Versions}}
{{#Kinds}}
        case "{{RawAPIVersion}}::{{Kind}}": {
            const [group, version] = "{{RawAPIVersion}}".split("/");
            gvk = version === undefined
                ? { group: "", version: group, kind: "{{Kind}}" }
                : { group, version, kind: "{{Kind}}" };
            pulumiType = "kubernetes:{{URNAPIVersion}}:{{Kind}}";
            filter = <any>k8s.{{Group}}.{{Version}}.{{Kind}}.isInstance;
            break;
        }
{{/Kinds}}
{{/Versions}}
{{/Groups}}
        default:
            throw new Error(`Can't list unsupported type '${apiVersion}::${kind}'`);
    }

    const invokeIterator = {
        [Symbol.asyncIterator]: function(): AsyncIterator<any> {
            let inv: AsyncIterator<any>;
            return {
                async next() {
                    if (inv === undefined) {
                        inv = (await pulumi.runtime.streamInvoke(
                            "kubernetes:kubernetes:list",
                            { ...gvk, namespace },
                        ))[Symbol.asyncIterator]();
                    }
                    return inv.next();
                },
            };
        },
    };

    return query
        .from(() => invokeIterator)
        .filter(resource => resource !== undefined)
        .map<ResolvedResource<U>>(({ type: typ, ...outputs }) => {
            return { ...outputs, __pulumiType: pulumiType };
        })
        .ofType(filter);
}

//
// Implementation of `watch`.
//

export type WatchTypes = "ADDED" | "MODIFIED" | "DELETED" | "ERROR";
export type WatchEvent<T> = { object: T; type: WatchTypes };

/**
 * Watches indefinitely for updates on all Kubernetes resources of a specific type live in a
 * cluster. Resource types are identified with traditional Kubernetes `apiVersion` and `kind`. For
 * example `watch("v1", "Pod")` will produce an infinite stream of updates to Pods in the active
 * kubeconfig context.
 *
 * By default, `watch` operates on the cluster and namespace identified by the active context of
 * the kubeconfig file. Namespace can be specified manually with the optional `namespace`
 * parameter.
 *
 * The return value of `watch` implements `AsyncIterable`, so it can be enumerated using
 * `for await`, as below.
 *
 * ```
 * for await (const pod of watch("v1", "Pod")) {
 *     console.log(pod.metadata!.name);
 * }
 * ```
 */
{{#Groups}}
{{#Versions}}
{{#Kinds}}
export function watch(apiVersion: "{{RawAPIVersion}}", kind: "{{Kind}}", namespace?: string): AsyncIterable<WatchEvent<ResolvedResource<k8s.{{Group}}.{{Version}}.{{Kind}}>>>;
{{/Kinds}}
{{/Versions}}
{{/Groups}}
export async function* watch<U extends Resource>(apiVersion: string, kind: string, namespace: string = "default") {

    let gvk: { group: string; version: string; kind: string };
    let pulumiType: string;
    let filter: (obj: any) => obj is ResolvedResource<U>;
    switch (`${apiVersion}::${kind}`) {
{{#Groups}}
{{#Versions}}
{{#Kinds}}
        case "{{RawAPIVersion}}::{{Kind}}": {
            const [group, version] = "{{RawAPIVersion}}".split("/");
            gvk = version === undefined
                ? { group: "", version: group, kind: "{{Kind}}" }
                : { group, version, kind: "{{Kind}}" };
            pulumiType = "kubernetes:{{URNAPIVersion}}:{{Kind}}";
            filter = <any>k8s.{{Group}}.{{Version}}.{{Kind}}.isInstance;
            break;
        }
{{/Kinds}}
{{/Versions}}
{{/Groups}}
        default:
            throw new Error(`Can't list unsupported type '${apiVersion}::${kind}'`);
    }

    const resources = streamInvoke("kubernetes:kubernetes:watch", gvk);

    for await (const {object, type} of await resources) {
        const typed = { ...object, __pulumiType: pulumiType };
        if (filter(typed)) {
            yield { object: typed, type } as WatchEvent<ResolvedResource<U>>;
        }
    }
}

export interface KubernetesResource {
    metadata?: {
        namespace?: string,
        name?: string,
    };
}

/**
 * `ResourceSet` watches the Kubernetes API server for resource updates, and uses them to maintain
 * an up-to-date copy of a set of resource definitions. Using `onUpdate`, users can take an
 * arbitrary action any time any resource in the set is updated.
 *
 * For example, in the following code, `ResourceSet` consumes updates to all `Pod`s in the active
 * kubeconfig context, and when any `Pod` is updated, it prints every `Pod`'s name.
 *
 * ```
 * new kq.ResourceSet([kq.watch("v1", "Pod")]).onUpdate(([events]) => {
 *     events.orderBy(p => p.metadata!.name).forEach(p => {
 *         console.log(`${p.metadata!.name}`)
 *     })
 * });
 * ```
 */
export class ResourceSet<
    A extends KubernetesResource,
    B = never | KubernetesResource,
    C = never | KubernetesResource,
    D = never | KubernetesResource,
    E = never | KubernetesResource,
    F = never | KubernetesResource,
    G = never | KubernetesResource,
    H = never | KubernetesResource,
    I = never | KubernetesResource,
    J = never | KubernetesResource,
> {

    static toResourceSet<T extends KubernetesResource>(
        acc: Map<string, T>,
        e: WatchEvent<T>,
    ): Map<string, T> {
        const { type, object } = e;
        const [ns, name] = [object.metadata!.namespace!, object.metadata!.name!];
        if (type === "DELETED") {
            acc.delete(`${ns}/${name}`);
        } else {
            acc.set(`${ns}/${name}`, object);
        }
        return acc;
    }

    constructor(watches: [AsyncIterable<WatchEvent<A>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>, AsyncIterable<WatchEvent<E>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>, AsyncIterable<WatchEvent<E>>, AsyncIterable<WatchEvent<F>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>, AsyncIterable<WatchEvent<E>>, AsyncIterable<WatchEvent<F>>, AsyncIterable<WatchEvent<G>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>, AsyncIterable<WatchEvent<E>>, AsyncIterable<WatchEvent<F>>, AsyncIterable<WatchEvent<G>>, AsyncIterable<WatchEvent<H>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>, AsyncIterable<WatchEvent<E>>, AsyncIterable<WatchEvent<F>>, AsyncIterable<WatchEvent<G>>, AsyncIterable<WatchEvent<H>>, AsyncIterable<WatchEvent<I>>])
    constructor(watches: [AsyncIterable<WatchEvent<A>>, AsyncIterable<WatchEvent<B>>, AsyncIterable<WatchEvent<C>>, AsyncIterable<WatchEvent<D>>, AsyncIterable<WatchEvent<E>>, AsyncIterable<WatchEvent<F>>, AsyncIterable<WatchEvent<G>>, AsyncIterable<WatchEvent<H>>, AsyncIterable<WatchEvent<I>>, AsyncIterable<WatchEvent<J>>])
    constructor(private watches: AsyncIterable<any>[]) {
        if (watches.length === 0) {
            throw new Error("Argument to ResourceSet must be a list with at least 1 element");
        }
    }

    public onUpdate(callback: (sets: [query.AsyncQueryable<A>, query.AsyncQueryable<B>, query.AsyncQueryable<C>, query.AsyncQueryable<D>, query.AsyncQueryable<E>, query.AsyncQueryable<F>, query.AsyncQueryable<G>, query.AsyncQueryable<H>, query.AsyncQueryable<I>, query.AsyncQueryable<J>]) => void): void;
    public onUpdate(callback: (sets: any) => void): void {
        const watches = this.watches.map(w => {
            const subject = new rx.Subject<WatchEvent<KubernetesResource>>();
            (async () => {
                for await (const resource of w) {
                    subject.next(resource);
                }
            })();
            return subject.pipe(
                scan(ResourceSet.toResourceSet, new Map()),
                map(m => query.from(() => m.values())),
            );
        });

        (async () => {
            rx.combineLatest(...watches).forEach(callback);
        })();
    }
}

export * from "./logs";
