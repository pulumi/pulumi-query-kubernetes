// Copyright 2016-2019, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
//

import * as k8s from "@pulumi/kubernetes";
import * as pulumi from "@pulumi/pulumi";
import { Resource } from "@pulumi/pulumi";
import { ResolvedResource } from "@pulumi/pulumi/queryable";
import { streamInvoke } from "@pulumi/pulumi/runtime";
import * as query from "@pulumi/query";
import { AsyncIterable } from "@pulumi/query/interfaces";
import * as rx from "rxjs";
import { map, scan } from "rxjs/operators";

//
// Implementation of `list`.
//

{{#Groups}}
{{#Versions}}
{{#Kinds}}
export function list(apiVersion: "{{RawAPIVersion}}", kind: "{{Kind}}"): query.AsyncQueryable<ResolvedResource<k8s.{{Group}}.{{Version}}.{{Kind}}>>;
{{/Kinds}}
{{/Versions}}
{{/Groups}}
export function list<U extends Resource>(apiVersion: string, kind: string): query.AsyncQueryable<ResolvedResource<U>> {

    let gvk: { group: string; version: string; kind: string };
    let pulumiType: string;
    let filter: (obj: any) => obj is ResolvedResource<U>;
    switch (`${apiVersion}::${kind}`) {
{{#Groups}}
{{#Versions}}
{{#Kinds}}
        case "{{RawAPIVersion}}::{{Kind}}": {
            const [group, version] = "{{RawAPIVersion}}".split("/");
            gvk = version === undefined
                ? { group: "", version: group, kind: "{{Kind}}" }
                : { group, version, kind: "{{Kind}}" };
            pulumiType = "kubernetes:{{URNAPIVersion}}:{{Kind}}";
            filter = <any>k8s.{{Group}}.{{Version}}.{{Kind}}.isInstance;
            break;
        }
{{/Kinds}}
{{/Versions}}
{{/Groups}}
        default:
            throw new Error(`Can't list unsupported type '${apiVersion}::${kind}'`);
    }

    const invokeIterator = {
        [Symbol.asyncIterator]: function(): AsyncIterator<any> {
            let inv: AsyncIterator<any>;
            return {
                async next() {
                    if (inv === undefined) {
                        inv = (await pulumi.runtime.streamInvoke(
                            "kubernetes:kubernetes:list",
                            gvk,
                        ))[Symbol.asyncIterator]();
                    }
                    return inv.next();
                },
            };
        },
    };

    return query
        .from(() => invokeIterator)
        .filter(resource => resource !== undefined)
        .map<ResolvedResource<U>>(({ type: typ, ...outputs }) => {
            return { ...outputs, __pulumiType: pulumiType };
        })
        .ofType(filter);
}

//
// Implementation of `watch`.
//

export type WatchTypes = "ADDED" | "MODIFIED" | "DELETED" | "ERROR";
export type WatchEvent<T> = { object: T; type: WatchTypes };

{{#Groups}}
{{#Versions}}
{{#Kinds}}
export function watch(apiVersion: "{{RawAPIVersion}}", kind: "{{Kind}}"): AsyncIterable<WatchEvent<ResolvedResource<k8s.{{Group}}.{{Version}}.{{Kind}}>>>;
{{/Kinds}}
{{/Versions}}
{{/Groups}}
export async function* watch<U extends Resource>(apiVersion: string, kind: string) {

    let gvk: { group: string; version: string; kind: string };
    let pulumiType: string;
    let filter: (obj: any) => obj is ResolvedResource<U>;
    switch (`${apiVersion}::${kind}`) {
{{#Groups}}
{{#Versions}}
{{#Kinds}}
        case "{{RawAPIVersion}}::{{Kind}}": {
            const [group, version] = "{{RawAPIVersion}}".split("/");
            gvk = version === undefined
                ? { group: "", version: group, kind: "{{Kind}}" }
                : { group, version, kind: "{{Kind}}" };
            pulumiType = "kubernetes:{{URNAPIVersion}}:{{Kind}}";
            filter = <any>k8s.{{Group}}.{{Version}}.{{Kind}}.isInstance;
            break;
        }
{{/Kinds}}
{{/Versions}}
{{/Groups}}
        default:
            throw new Error(`Can't list unsupported type '${apiVersion}::${kind}'`);
    }

    const resources = streamInvoke("kubernetes:kubernetes:watch", gvk);

    for await (const {object, type} of await resources) {
        const typed = { ...object, __pulumiType: pulumiType };
        if (filter(typed)) {
            yield { object: typed, type } as WatchEvent<ResolvedResource<U>>;
        }
    }
}

export class ResourceSet<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never> {
    static toResourceSet<T extends { metadata?: k8s.types.output.meta.v1.ObjectMeta }>(
        acc: Map<string, T>,
        e: WatchEvent<T>,
    ): Map<string, T> {
        const { object } = e;
        const [ns, name] = [object.metadata!.namespace!, object.metadata!.name!];
        acc.set(`${ns}/${name}`, object);
        return acc;
    }

    constructor(watches: [AsyncIterable<A>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>, AsyncIterable<E>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>, AsyncIterable<E>, AsyncIterable<F>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>, AsyncIterable<E>, AsyncIterable<F>, AsyncIterable<G>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>, AsyncIterable<E>, AsyncIterable<F>, AsyncIterable<G>, AsyncIterable<H>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>, AsyncIterable<E>, AsyncIterable<F>, AsyncIterable<G>, AsyncIterable<H>, AsyncIterable<I>])
    constructor(watches: [AsyncIterable<A>, AsyncIterable<B>, AsyncIterable<C>, AsyncIterable<D>, AsyncIterable<E>, AsyncIterable<F>, AsyncIterable<G>, AsyncIterable<H>, AsyncIterable<I>, AsyncIterable<J>])
    constructor(private watches: AsyncIterable<any>[]) {}

    public onUpdate(callback: (sets: [query.AsyncQueryable<A>, query.AsyncQueryable<B>, query.AsyncQueryable<C>, query.AsyncQueryable<D>, query.AsyncQueryable<E>, query.AsyncQueryable<F>, query.AsyncQueryable<G>, query.AsyncQueryable<H>, query.AsyncQueryable<I>, query.AsyncQueryable<J>]) => void): void;
    public onUpdate(callback: (sets: any) => void): void {
        const watches = this.watches.map(w => {
            const subject = new rx.Subject<any>();
            (async () => {
                for await (const resource of w) {
                    subject.next(resource);
                }
            })();
            return subject.pipe(
                scan(ResourceSet.toResourceSet, new Map()),
                map(m => query.from(() => m.values())),
            );
        });

        (async () => {
            rx.combineLatest(...watches).forEach(callback);
        })();
    }
}

export * from "./logs";
